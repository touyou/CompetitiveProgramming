import java.util.*;  

public class BeautifulCrossword {
     private char[][] solution, bestSolution;     
     private double best, NN;     
     private boolean[] used;     
     private int[][] wordsBySize;     
     private int[][][][] wordsBySizePosChar;     
     private int N, w1, w2, w3, w4;     
     private String[] words;     
     private final long timeout = System.currentTimeMillis() + 8000;     
     private final Random rnd = new Random(9);      
     
     public String[] generateCrossword(int N, String[] pwords, int[] weights) {
         w1 = weights[0];         
         w2 = weights[1];         
         w3 = weights[2];         
         w4 = weights[3];         
         this.N = N;         
         this.words = new String[pwords.length];         
         used = new boolean[words.length];         
         System.arraycopy(pwords, 0, words, 0, pwords.length);         
         NN = N * N;         
         solution = new char[N][N];         
         bestSolution = new char[N][N];         
         eval();         
         sortWords();          
         double m2 = mount2(3, 2, 6);         
         double m12 = mount1(2);         
         double m13 = mount1(3);         
         int cyc = 0;         
         while (System.currentTimeMillis() < timeout) {             
         	mixWords();             
         	if (m12 >= m13 && m12 >= m2) mount1(2);             
         	else if (m13 >= m2) mount1(3);             
         	else mount2(3 + rnd.nextInt(5), rnd.nextBoolean() ? 2 : rnd.nextBoolean() ? 1 : 0, rnd.nextBoolean()?7:6);             
         	cyc++;         
         }         
         return mountRet();    
     }      
     
     private void prepareWords() {         
     	int[] cnt = new int[16];         
     	int[][][] cnt2 = new int[16][15][26];         
     	if (wordsBySize == null) {             
     	for (int i = 0; i < words.length; i++) {                 
     		String wi = words[i];                 
     		int len = wi.length();                 
     		cnt[len]++;                 
     		for (int j = 0; j < len; j++) {                     
     			cnt2[len][j][wi.charAt(j) - 'A']++;                 
     		}             
     	}             
     	wordsBySize = new int[16][];             
     	wordsBySizePosChar = new int[16][15][26][];             
     	for (int i = 0; i < 16; i++) {                 
     		wordsBySize[i] = new int[cnt[i]];                 
     		cnt[i] = 0;                 
     		for (int j = 0; j < i; j++) {                     
     			for (int k = 'A'; k <= 'Z'; k++) {                         
     				wordsBySizePosChar[i][j][k - 'A'] = new int[cnt2[i][j][k - 'A']];                         
     				cnt2[i][j][k - 'A'] = 0;                     
     			}                 
     		}             
     	}         
     }         
     for (int i = 0; i < words.length; i++) {             
     	String wi = words[i];             
     	int len = wi.length();             
     	wordsBySize[len][cnt[len]++] = i;              
     	for (int j = 0; j < len; j++) {                 
     		int ch = wi.charAt(j) - 'A';                 wordsBySizePosChar[len][j][ch][cnt2[len][j][ch]++] = i;             }         }     }      private void mixWords() {         for (int i = 0; i < words.length; i++) {             int p1 = rnd.nextInt(words.length);             int p2 = p1 + rnd.nextInt(7) - 3;             if (p2 == p1 || p2 < 0 || p2 >= words.length) continue;             String aux = words[p1];             words[p1] = words[p2];             words[p2] = aux;         }         prepareWords();     }      private int countFreeWords(int len) {         int cnt = 0;         for (int i = 0; i < words.length; i++) {             if (!used[i] && words[i].length() == len) cnt++;         }         return cnt;     }      private double mount2(int start, int mdir, int gm) {         if (System.currentTimeMillis() > timeout) return 0;         initSolution();         int pos = 0;         int lmode = 0;         for (int groupSize = 6; groupSize >= 4; groupSize -= 2) {             for (int j = start; j <= 8; j++) {                 OUT: while (pos + j < (N + 1) / 2) {                     if (countFreeWords(j) < groupSize * 4) break;                     for (int mode = 2; mode >= 0; mode--) {                         if (j <= mode * 2 + 2 + (groupSize == 6 ? 2 : 0)) continue;                          int[] f1 = getGroup(j, j, mode, mode, groupSize, 0);                         if (f1 == null) break;                         for (int i = 0; i < f1.length; i++) {                             used[f1[i]] = true;                         }                         int[] f2 = getGroup(j, j, mode, mode, groupSize, 0);                         if (f2 == null) {                             for (int i = 0; i < f1.length; i++) {                                 used[f1[i]] = false;                             }                             break;                         }                         for (int i = 0; i < f1.length; i++) {                             used[f2[i]] = true;                         }                         int[] f3 = getGroup(j, j, mode, mode, groupSize, 0);                         if (f3 == null) {                             for (int i = 0; i < f1.length; i++) {                                 used[f1[i]] = used[f2[i]] = false;                             }                             break;                         }                         for (int i = 0; i < f1.length; i++) {                             used[f3[i]] = true;                         }                         int[] f4 = getGroup(j, j, mode, mode, groupSize, 0);                         if (f4 == null) {                             for (int i = 0; i < f1.length; i++) {                                 used[f1[i]] = used[f2[i]] = used[f3[i]] = false;                             }                             break;                         }                         if (lmode == 2 && mode == 0) pos--;                         if (lmode == 0 && mode == 2) pos--;                         if (lmode == 2 && mode == 1) pos--;                         if (lmode == 1 && mode == 2) pos--;                         if (lmode == 1 && mode == 1) pos--;                         if (lmode == 2 && mode == 2) pos -= 2;                         if (pos < 0) pos = 0;                         lmode = mode;                         placeGroup(f1, pos, pos, mode, mode, 0);                         placeGroup(f2, N - j - pos, N - j - pos, mode, mode, 0);                         placeGroup(f3, pos, N - j - pos, mode, mode, 0);                         placeGroup(f4, N - j - pos, pos, mode, mode, 0);                         pos += j;                         continue OUT;                     }                     break;                 }             }         }         eval();         placeCenter();         placeCross();          double ret = eval();          for (int groupSize = gm; groupSize >= 4; groupSize--) {             for (int sum = 6; sum <= 30; sum++) {                 for (int h = 3; h <= 15; h++) {                     if (System.currentTimeMillis() > timeout) return ret;                     NEXT: for (int w = h; w <= 15; w++) {                         if (w + h != sum) continue;                         if (w % 2 != N % 2) continue;                         if (countFreeWords(w) < groupSize * 2 || countFreeWords(h) < groupSize * 2) continue;                         for (int dir = 0; dir <= mdir; dir++) {                             if (groupSize == 4 && dir != 0) continue;                             if (groupSize == 5 && dir > 1) continue;                             if (groupSize == 7 && dir > 1) continue;                             for (int sm = 0; sm <= 12; sm++) {                                 for (int modew = 0; modew <= 6; modew++) {                                     for (int modeh = 0; modeh <= 6; modeh++) {                                         if (modew + modeh != sm) continue;                                          int minw = modew * 2 + 2;                                         if ((groupSize == 6 && dir == 0) || (groupSize == 5 && dir == 1)) minw += 2;                                         else if (groupSize == 6 && dir == 1) minw += 4;                                         else if (groupSize == 7 && dir == 1) minw += 6;                                         if (w <= minw) continue;                                          int minh = modeh * 2 + 2;                                         if ((groupSize == 6 && dir == 0) || (groupSize == 5 && dir == 0)) minh += 2;                                         else if (groupSize == 6 && dir == 2) minh += 4;                                         else if (groupSize == 7 && dir == 0) minh += 6;                                         if (h <= minh) continue;                                          int rdir = dir;                                         if (groupSize == 5 || groupSize == 7) rdir = 1 - dir;                                         else if (groupSize == 6) rdir = dir == 0 ? 0 : 3 - dir;                                          int y = (N + 1) / 2 - h;                                         boolean ok = false;                                         while (y >= 0) {                                             if (N / 2 - w / 2 <= y + h - 1) {                                                 y--;                                                 continue;                                             }                                             if (fitAnyGroup(w, h, N / 2 - w / 2, y, modew, modeh)) {                                                 ok = true;                                                 break;                                             }                                             y--;                                         }                                         if (!ok) continue;                                          int[] f1 = getGroup(w, h, modew, modeh, groupSize, dir);                                         if (f1 == null) continue;                                         for (int i = 0; i < groupSize; i++) {                                             used[f1[i]] = true;                                         }                                         int[] f2 = getGroup(w, h, modew, modeh, groupSize, dir);                                         if (f2 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f2[i]] = true;                                         }                                         int[] f3 = getGroup(h, w, modeh, modew, groupSize, rdir);                                         if (f3 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f3[i]] = true;                                         }                                         int[] f4 = getGroup(h, w, modeh, modew, groupSize, rdir);                                         if (f4 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = used[f3[i]] = false;                                             }                                             continue;                                         }                                         y = (N + 1) / 2 - h;                                         while (y >= 0) {                                             if (N / 2 - w / 2 <= y + h - 1) {                                                 y--;                                                 continue;                                             }                                             if (fitGroup(f1, N / 2 - w / 2, y, modew, modeh, dir) && fitGroup(f2, N / 2 - w / 2, N - h - y, modew, modeh, dir) && fitGroup(                                                     f3, y, N / 2 - w / 2, modeh, modew, rdir) && fitGroup(f4, N - h - y, N / 2 - w / 2, modeh, modew, rdir)) {                                                 placeGroup(f1, N / 2 - w / 2, y, modew, modeh, dir);                                                 placeGroup(f2, N / 2 - w / 2, N - h - y, modew, modeh, dir);                                                 placeGroup(f3, y, N / 2 - w / 2, modeh, modew, rdir);                                                 placeGroup(f4, N - h - y, N / 2 - w / 2, modeh, modew, rdir);                                                 ret = Math.max(eval(), ret);                                                 w--;                                                 continue NEXT;                                             }                                             y--;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f1[i]] = used[f2[i]] = used[f3[i]] = used[f4[i]] = false;                                         }                                     }                                 }                             }                         }                     }                 }             }         }         ret = Math.max(eval(), ret);         for (int groupSize = gm; groupSize >= 4; groupSize--) {             for (int sum = 6; sum <= 30; sum++) {                 for (int h = 3; h <= 15; h++) {                     if (System.currentTimeMillis() > timeout) return ret;                     NEXT: for (int w = h; w <= 15; w++) {                         if (w + h != sum) continue;                         if (w % 2 != N % 2) continue;                         if (countFreeWords(w) < groupSize * 4 || countFreeWords(h) < groupSize * 4) continue;                         for (int dir = 0; dir <= mdir; dir++) {                             if (groupSize == 4 && dir != 0) continue;                             if (groupSize == 5 && dir > 1) continue;                             if (groupSize == 7 && dir > 1) continue;                              for (int sm = 0; sm <= 12; sm++) {                                 for (int modew = 0; modew <= 6; modew++) {                                     for (int modeh = 0; modeh <= 6; modeh++) {                                         if (modew + modeh != sm) continue;                                          int minw = modew * 2 + 2;                                         if ((groupSize == 6 && dir == 0) || (groupSize == 5 && dir == 1)) minw += 2;                                         else if (groupSize == 6 && dir == 1) minw += 4;                                         else if (groupSize == 7 && dir == 1) minw += 6;                                         if (w <= minw) continue;                                          int minh = modeh * 2 + 2;                                         if ((groupSize == 6 && dir == 0) || (groupSize == 5 && dir == 0)) minh += 2;                                         else if (groupSize == 6 && dir == 2) minh += 4;                                         else if (groupSize == 7 && dir == 0) minh += 6;                                         if (h <= minh) continue;                                          int rdir = dir;                                         if (groupSize == 5 || groupSize == 7) rdir = 1 - dir;                                         else if (groupSize == 6) rdir = dir == 0 ? 0 : 3 - dir;                                          int y = 0;                                         boolean ok = false;                                         OUT: while (y < N / 2 - h) {                                             int x = (N - 1) / 2 - w;                                             while (x > y + h) {                                                 if (fitAnyGroup(w, h, x, y, modew, modeh)) {                                                     ok = true;                                                     break OUT;                                                 }                                                 x--;                                             }                                             y++;                                         }                                         if (!ok) continue;                                          int[] f1 = getGroup(w, h, modew, modeh, groupSize, dir);                                         if (f1 == null) continue;                                         for (int i = 0; i < groupSize; i++) {                                             used[f1[i]] = true;                                         }                                          int[] f2 = getGroup(w, h, modew, modeh, groupSize, dir);                                         if (f2 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f2[i]] = true;                                         }                                         int[] f3 = getGroup(h, w, modeh, modew, groupSize, rdir);                                         if (f3 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f3[i]] = true;                                         }                                         int[] f4 = getGroup(h, w, modeh, modew, groupSize, rdir);                                         if (f4 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = used[f3[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f4[i]] = true;                                         }                                         int[] f5 = getGroup(w, h, modew, modeh, groupSize, dir);                                         if (f5 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = used[f3[i]] = used[f4[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f5[i]] = true;                                         }                                         int[] f6 = getGroup(w, h, modew, modeh, groupSize, dir);                                         if (f6 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = used[f3[i]] = used[f4[i]] = used[f5[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f6[i]] = true;                                         }                                         int[] f7 = getGroup(h, w, modeh, modew, groupSize, rdir);                                         if (f7 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = used[f3[i]] = used[f4[i]] = used[f5[i]] = used[f6[i]] = false;                                             }                                             continue;                                         }                                         for (int i = 0; i < groupSize; i++) {                                             used[f7[i]] = true;                                         }                                         int[] f8 = getGroup(h, w, modeh, modew, groupSize, rdir);                                         if (f8 == null) {                                             for (int i = 0; i < groupSize; i++) {                                                 used[f1[i]] = used[f2[i]] = used[f3[i]] = used[f4[i]] = used[f5[i]] = used[f6[i]] = used[f7[i]] = false;                                             }                                             continue;                                         }                                         y = 0;                                         while (y < N / 2 - h) {                                             int x = (N - 1) / 2 - w;                                             while (x > y + h) {                                                  if (fitGroup(f1, x, y, modew, modeh, dir) && fitGroup(f2, N - w - x, y, modew, modeh, dir) && fitGroup(f3, y,                                                         x, modeh, modew, rdir) && fitGroup(f4, y, N - w - x, modeh, modew, rdir) && fitGroup(f5, x, N - h - y,                                                         modew, modeh, dir) && fitGroup(f6, N - w - x, N - h - y, modew, modeh, dir) && fitGroup(f7, N - h - y,                                                         x, modeh, modew, rdir) && fitGroup(f8, N - h - y, N - w - x, modeh, modew, rdir)) {                                                      placeGroup(f1, x, y, modew, modeh, dir);                                                     placeGroup(f2, N - w - x, y, modew, modeh, dir);                                                     placeGroup(f3, y, x, modeh, modew, rdir);                                                     placeGroup(f4, y, N - w - x, modeh, modew, rdir);                                                      placeGroup(f5, x, N - h - y, modew, modeh, dir);                                                     placeGroup(f6, N - w - x, N - h - y, modew, modeh, dir);                                                     placeGroup(f7, N - h - y, x, modeh, modew, rdir);                                                     placeGroup(f8, N - h - y, N - w - x, modeh, modew, rdir);                                                      w--;                                                     ret = Math.max(eval(), ret);                                                     continue NEXT;                                                 }                                                 x--;                                             }                                             y++;                                         }                                         for (int i = 0; i < 4; i++) {                                             used[f1[i]] = used[f2[i]] = used[f3[i]] = used[f4[i]] = used[f5[i]] = used[f6[i]] = used[f7[i]] = used[f8[i]] = false;                                         }                                     }                                 }                             }                         }                     }                 }             }         }         diagCross();         improveSym();          return improve();     }      private boolean putH(int len) {         if (countFreeWords(len) < 8) return false;         for (int y = 0; y < N / 2; y++) {             POS: for (int x = y + 1; x < (N + 1) / 2 - len; x++) {                 if (!fitAnyH(len, x, y)) continue;                 int[] px = new int[] {x,N - len - x,N - len - x,x,y,N - 1 - y,N - 1 - y,y};                 int[] py = new int[] {y,y,N - 1 - y,N - 1 - y,x,x,N - x - len,N - x - len};                 int[][] cand = new int[8][8];                 int[] cnt = new int[8];                 for (int pos = 0; pos < 8; pos++) {                     for (int a : wordsBySize[len]) {                         if (used[a]) continue;                         String s = words[a];                         if (pos < 4) {                             if (!fitH(s, px[pos], py[pos])) continue;                         } else {                             if (!fitV(s, px[pos], py[pos])) continue;                         }                         cand[pos][cnt[pos]++] = a;                         if (cnt[pos] == 8) break;                     }                     if (cnt[pos] == 0) continue POS;                 }                 for (int c1 = 0; c1 < cnt[0]; c1++) {                     int a1 = cand[0][c1];                     for (int c2 = 0; c2 < cnt[1]; c2++) {                         int a2 = cand[1][c2];                         if (a1 == a2) continue;                         for (int c3 = 0; c3 < cnt[2]; c3++) {                             int a3 = cand[2][c3];                             if (a1 == a3 || a2 == a3) continue;                             for (int c4 = 0; c4 < cnt[3]; c4++) {                                 int a4 = cand[3][c4];                                 if (a1 == a4 || a2 == a4 || a3 == a4) continue;                                 for (int c5 = 0; c5 < cnt[4]; c5++) {                                     int a5 = cand[4][c5];                                     if (a1 == a5 || a2 == a5 || a3 == a5 || a4 == a5) continue;                                     for (int c6 = 0; c6 < cnt[5]; c6++) {                                         int a6 = cand[5][c6];                                         if (a1 == a6 || a2 == a6 || a3 == a6 || a4 == a6 || a5 == a6) continue;                                         for (int c7 = 0; c7 < cnt[6]; c7++) {                                             int a7 = cand[6][c7];                                             if (a1 == a7 || a2 == a7 || a3 == a7 || a4 == a7 || a5 == a7 || a6 == a7) continue;                                             for (int c8 = 0; c8 < cnt[7]; c8++) {                                                 int a8 = cand[7][c8];                                                 if (a1 == a8 || a2 == a8 || a3 == a8 || a4 == a8 || a5 == a8 || a6 == a8 || a7 == a8) continue;                                                  placeH(a1, px[0], py[0]);                                                 placeH(a2, px[1], py[1]);                                                 placeH(a3, px[2], py[2]);                                                 placeH(a4, px[3], py[3]);                                                 placeV(a5, px[4], py[4]);                                                 placeV(a6, px[5], py[5]);                                                 placeV(a7, px[6], py[6]);                                                 placeV(a8, px[7], py[7]);                                                 return true;                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }         return false;     }      private boolean putV(int len) {         if (countFreeWords(len) < 8) return false;         for (int y = 0; y < (N + 1) / 2 - len; y++) {             POS: for (int x = y + len + 1; x < (N - 1) / 2; x++) {                 if (!fitAnyV(len, x, y)) continue;                 int[] px = new int[] {x,N - 1 - x,x,N - 1 - x,y,N - len - y,y,N - len - y};                 int[] py = new int[] {y,y,N - len - y,N - len - y,x,x,N - 1 - x,N - 1 - x};                 int[][] cand = new int[8][8];                 int[] cnt = new int[8];                 for (int pos = 0; pos < 8; pos++) {                     for (int a : wordsBySize[len]) {                         if (used[a]) continue;                         String s = words[a];                         if (pos < 4) {                             if (!fitV(s, px[pos], py[pos])) continue;                         } else {                             if (!fitH(s, px[pos], py[pos])) continue;                         }                         cand[pos][cnt[pos]++] = a;                         if (cnt[pos] == 8) break;                     }                     if (cnt[pos] == 0) continue POS;                 }                 for (int c1 = 0; c1 < cnt[0]; c1++) {                     int a1 = cand[0][c1];                     for (int c2 = 0; c2 < cnt[1]; c2++) {                         int a2 = cand[1][c2];                         if (a1 == a2) continue;                         for (int c3 = 0; c3 < cnt[2]; c3++) {                             int a3 = cand[2][c3];                             if (a1 == a3 || a2 == a3) continue;                             for (int c4 = 0; c4 < cnt[3]; c4++) {                                 int a4 = cand[3][c4];                                 if (a1 == a4 || a2 == a4 || a3 == a4) continue;                                 for (int c5 = 0; c5 < cnt[4]; c5++) {                                     int a5 = cand[4][c5];                                     if (a1 == a5 || a2 == a5 || a3 == a5 || a4 == a5) continue;                                     for (int c6 = 0; c6 < cnt[5]; c6++) {                                         int a6 = cand[5][c6];                                         if (a1 == a6 || a2 == a6 || a3 == a6 || a4 == a6 || a5 == a6) continue;                                         for (int c7 = 0; c7 < cnt[6]; c7++) {                                             int a7 = cand[6][c7];                                             if (a1 == a7 || a2 == a7 || a3 == a7 || a4 == a7 || a5 == a7 || a6 == a7) continue;                                             for (int c8 = 0; c8 < cnt[7]; c8++) {                                                 int a8 = cand[7][c8];                                                 if (a1 == a8 || a2 == a8 || a3 == a8 || a4 == a8 || a5 == a8 || a6 == a8 || a7 == a8) continue;                                                  placeV(a1, px[0], py[0]);                                                 placeV(a2, px[1], py[1]);                                                 placeV(a3, px[2], py[2]);                                                 placeV(a4, px[3], py[3]);                                                 placeH(a5, px[4], py[4]);                                                 placeH(a6, px[5], py[5]);                                                 placeH(a7, px[6], py[6]);                                                 placeH(a8, px[7], py[7]);                                                 eval();                                                 return true;                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }         return false;     }      private void improveSym() {         for (int len = 15; len >= 3; len--) {             int t = 1;             while (t > 0) {                 if (t == 1) {                     t = 0;                     if (putH(len)) t = 2;                     else if (putV(len)) t = 1;                 } else {                     t = 0;                     if (putV(len)) t = 1;                     else if (putH(len)) t = 2;                 }             }         }      }      private void diagCross() {         if (N % 2 == 1) {             for (int i = 3; i <= 15; i += 2) {                 if (countFreeWords(i) < 8) continue;                 int i2 = i / 2;                 NEXT: for (int x = i; x < N / 2 - i; x++) {                     for (int a1 = 0; a1 < words.length; a1++) {                         if (used[a1]) continue;                         String s1 = words[a1];                         if (s1.length() != i) continue;                         if (!fitH(s1, x - i2, x)) continue;                         for (int a2 = 0; a2 < words.length; a2++) {                             if (a1 == a2 || used[a2]) continue;                             String s2 = words[a2];                             if (s2.length() != i) continue;                             if (s2.charAt(i2) != s1.charAt(i2)) continue;                             if (!fitV(s2, x, x - i2)) continue;                             for (int a3 = 0; a3 < words.length; a3++) {                                 if (a1 == a3 || a2 == a3 || used[a3]) continue;                                 String s3 = words[a3];                                 if (s3.length() != i) continue;                                 if (!fitH(s3, N - x - i2 - 1, x)) continue;                                 for (int a4 = 0; a4 < words.length; a4++) {                                     if (a1 == a4 || a2 == a4 || a3 == a4 || used[a4]) continue;                                     String s4 = words[a4];                                     if (s4.length() != i) continue;                                     if (s4.charAt(i2) != s3.charAt(i2)) continue;                                     if (!fitV(s4, N - x - 1, x - i2)) continue;                                     for (int a5 = 0; a5 < words.length; a5++) {                                         if (a1 == a5 || a2 == a5 || a3 == a5 || a4 == a5 || used[a5]) continue;                                         String s5 = words[a5];                                         if (s5.length() != i) continue;                                         if (!fitH(s5, x - i2, N - x - 1)) continue;                                         for (int a6 = 0; a6 < words.length; a6++) {                                             if (a1 == a6 || a2 == a6 || a3 == a6 || a4 == a6 || a5 == a6 || used[a6]) continue;                                             String s6 = words[a6];                                             if (s6.length() != i) continue;                                             if (s5.charAt(i2) != s6.charAt(i2)) continue;                                             if (!fitV(s6, x, N - x - i2 - 1)) continue;                                             for (int a7 = 0; a7 < words.length; a7++) {                                                 if (a1 == a7 || a2 == a7 || a3 == a7 || a4 == a7 || a5 == a7 || a6 == a7 || used[a7]) continue;                                                 String s7 = words[a7];                                                 if (s7.length() != i) continue;                                                 if (!fitH(s7, N - x - i2 - 1, N - x - 1)) continue;                                                 for (int a8 = 0; a8 < words.length; a8++) {                                                     if (a1 == a8 || a2 == a8 || a3 == a8 || a4 == a8 || a5 == a8 || a6 == a8 || a7 == a8 || used[a8]) continue;                                                     String s8 = words[a8];                                                     if (s8.length() != i) continue;                                                     if (s7.charAt(i2) != s8.charAt(i2)) continue;                                                     if (!fitV(s8, N - x - 1, N - x - i2 - 1)) continue;                                                      placeH(a1, x - i2, x);                                                     placeV(a2, x, x - i2);                                                     placeH(a3, N - x - i2 - 1, x);                                                     placeV(a4, N - x - 1, x - i2);                                                     placeH(a5, x - i2, N - x - 1);                                                     placeV(a6, x, N - x - i2 - 1);                                                     placeH(a7, N - x - i2 - 1, N - x - 1);                                                     placeV(a8, N - x - 1, N - x - i2 - 1);                                                     eval();                                                     continue NEXT;                                                 }                                             }                                         }                                     }                                 }                             }                         }                     }                 }             }         }     }      private boolean fitAnyGroup(int w, int h, int x, int y, int modew, int modeh) {         if (!fitAnyH(w, x, y + modeh)) return false;         if (!fitAnyV(h, x + modew, y)) return false;         if (!fitAnyV(h, x + w - 1 - modew, y)) return false;         if (!fitAnyH(w, x, y + h - 1 - modeh)) return false;         return true;     }      private boolean fitGroup(int[] f, int x, int y, int modew, int modeh, int dir) {         if (!fitH(words[f[0]], x, y + modeh)) return false;         if (!fitV(words[f[1]], x + modew, y)) return false;         int w = words[f[0]].length();         if (!fitV(words[f[2]], x + w - 1 - modew, y)) return false;         int h = words[f[1]].length();         if (!fitH(words[f[3]], x, y + h - 1 - modeh)) return false;         if (f.length == 7) {             if (dir == 0) {                 if (!fitH(words[f[4]], x, y + modeh + 2)) return false;                 if (!fitH(words[f[5]], x, y + words[f[1]].length() / 2)) return false;                 if (!fitH(words[f[6]], x, y + words[f[1]].length() - 1 - modeh - 2)) return false;             } else if (dir == 1) {                 if (!fitV(words[f[4]], x + modew + 2, y)) return false;                 if (!fitV(words[f[5]], x + words[f[0]].length() / 2, y)) return false;                 if (!fitV(words[f[6]], x + words[f[0]].length() - 1 - modew - 2, y)) return false;             }         } else if (f.length == 6) {             if (dir == 0) {                 if (!fitV(words[f[4]], x + w / 2, y)) return false;                 if (!fitH(words[f[5]], x, y + h / 2)) return false;             } else if (dir == 1) {                 if (!fitV(words[f[4]], x + modew + 2, y)) return false;                 if (!fitV(words[f[5]], x + w - 1 - modew - 2, y)) return false;             } else if (dir == 2) {                 if (!fitH(words[f[4]], x, y + modeh + 2)) return false;                 if (!fitH(words[f[5]], x, y + h - 1 - modeh - 2)) return false;             }         } else if (f.length == 5) {             if (dir == 0 && !fitH(words[f[4]], x, y + h / 2)) return false;             if (dir == 1 && !fitV(words[f[4]], x + w / 2, y)) return false;         }         return true;     }      private void placeGroup(int[] f, int x, int y, int modew, int modeh, int dir) {         placeH(f[0], x, y + modeh);         placeV(f[1], x + modew, y);         placeV(f[2], x + words[f[0]].length() - 1 - modew, y);         placeH(f[3], x, y + words[f[1]].length() - 1 - modeh);         if (f.length == 7) {             if (dir == 0) {                 placeH(f[4], x, y + modeh + 2);                 placeH(f[5], x, y + words[f[1]].length() / 2);                 placeH(f[6], x, y + words[f[1]].length() - 1 - modeh - 2);             } else if (dir == 1) {                 placeV(f[4], x + modew + 2, y);                 placeV(f[5], x + words[f[0]].length() / 2, y);                 placeV(f[6], x + words[f[0]].length() - 1 - modew - 2, y);             } else System.err.println(">>>");         } else if (f.length == 6) {             if (dir == 0) {                 placeV(f[4], x + words[f[0]].length() / 2, y);                 placeH(f[5], x, y + words[f[1]].length() / 2);             } else if (dir == 1) {                 placeV(f[4], x + modew + 2, y);                 placeV(f[5], x + words[f[0]].length() - 1 - modew - 2, y);             } else if (dir == 2) {                 placeH(f[4], x, y + modeh + 2);                 placeH(f[5], x, y + words[f[1]].length() - 1 - modeh - 2);             }         } else if (f.length == 5) {             if (dir == 0) placeH(f[4], x, y + words[f[1]].length() / 2);             if (dir == 1) placeV(f[4], x + words[f[0]].length() / 2, y);         }     }      private boolean addMiddle(int i) {         int free = -1;         for (int j = i; j < N / 2; j++) {             if (solution[i][j] == 0 && solution[i][j + 1] == 0) {                 free = j + 1;                 break;             }         }         if (free < 0) return false;         List<Integer> l = new ArrayList<Integer>();         for (int j = 15; j > 2; j--) {             if (free + j >= (N + 1) / 2 - 4) continue;             l.clear();             for (int k = 0; k < words.length; k++) {                 if (used[k]) continue;                 String sk = words[k];                 if (sk.length() != j) continue;                 l.add(k);                 if (l.size() == 8) {                     placeH(l.get(0), free, i);                     placeH(l.get(1), N - free - j, i);                     placeH(l.get(2), free, N - i - 1);                     placeH(l.get(3), N - free - j, N - i - 1);                     placeV(l.get(4), i, free);                     placeV(l.get(5), N - i - 1, free);                     placeV(l.get(6), i, N - free - j);                     placeV(l.get(7), N - i - 1, N - free - j);                     return true;                 }             }         }         return false;     }      private void addCorner(int i) {         int max = (N + 1) / 2 - i;         int single = N - 2 * i;         if (single <= 15) {             int[] f = getGroup(single, single);             if (f != null) {                 placeH(f[0], i, i);                 placeV(f[1], i, i);                 placeV(f[2], N - i - 1, i);                 placeH(f[3], i, N - i - 1);                 return;             }         }         while (max > 2) {             int[] str1 = getPair(-1, max, true, true, true);             if (str1 == null) break;             int len = words[str1[0]].length();             used[str1[0]] = true;             used[str1[1]] = true;             int[] str2 = getPair(len, max, true, false, true);             if (str2 == null) {                 max = len - 1;                 used[str1[0]] = false;                 used[str1[1]] = false;                 continue;             }             used[str2[0]] = true;             used[str2[1]] = true;             int[] str3 = getPair(len, max, false, false, true);             if (str3 == null) {                 max = len - 1;                 used[str1[0]] = false;                 used[str1[1]] = false;                 used[str2[0]] = false;                 used[str2[1]] = false;                 continue;             }             used[str3[0]] = true;             used[str3[1]] = true;             int[] str4 = getPair(len, max, false, true, true);             if (str4 == null) {                 max = len - 1;                 used[str1[0]] = false;                 used[str1[1]] = false;                 used[str2[0]] = false;                 used[str2[1]] = false;                 used[str3[0]] = false;                 used[str3[1]] = false;                 continue;             }             used[str4[0]] = true;             used[str4[1]] = true;              placeH(str1[0], i, i);             placeV(str1[1], i, i);             placeV(str2[0], N - 1 - i, i);             placeH(str2[1], N - i - words[str2[1]].length(), i);             placeV(str3[0], N - i - 1, N - i - words[str3[0]].length());             placeH(str3[1], N - i - words[str3[1]].length(), N - i - 1);             placeV(str4[0], i, N - i - words[str4[0]].length());             placeH(str4[1], i, N - i - 1);             break;         }     }      private boolean addCenter(int i) {         int free = -1;         for (int j = i; j < N / 2; j++) {             if (solution[i][j] == 0 && solution[i][j + 1] == 0) {                 free = j + 1;                 break;             }         }         if (free < 0) return true;         int size = 0;         for (int j = free; j < N - i - 1; j++) {             if (solution[i][j + 1] == 0) {                 size++;             } else break;         }         while (size > 2) {             List<Integer> l = new ArrayList<Integer>();             for (int k = 0; k < words.length; k++) {                 String sk = words[k];                 if (sk.length() != size) continue;                 if (used[k]) continue;                 l.add(k);                 if (l.size() == 4) break;             }             if (l.size() == 4) {                 placeH(l.get(0), free, i);                 placeH(l.get(1), free, N - i - 1);                 placeV(l.get(2), i, free);                 placeV(l.get(3), N - i - 1, free);                 return true;             }             size -= 2;             free++;         }         return false;     }      private double mount1(int gap) {         if (System.currentTimeMillis() > timeout) return 0;         initSolution();         for (int i = 0; i < N / 2; i += gap) {             addCorner(i);         }         for (int i = 0; i < N / 2; i += gap) {             while (addMiddle(i)) {             }         }         for (int i = 0; i < N / 2; i += gap) {             addCenter(i);         }         placeCenter();         placeCross();         eval();         improveSym();         return improve();     }      private void placeCross() {         if (N % 2 == 1) {             for (int i = 13; i >= 3; i -= 2) {                 char[] aux = new char[i];                 Arrays.fill(aux, (char) (i + '0'));                 if (fitH(new String(aux), N / 2 - i / 2, N / 2)) {                     int[] f = getCross(i);                     if (f != null) {                         placeH(f[0], N / 2 - i / 2, N / 2);                         placeV(f[1], N / 2, N / 2 - i / 2);                         break;                     }                 }             }         }     }      private void placeCenter() {         for (int groupSize = 6; groupSize >= 4; groupSize -= 2) {             for (int i = N % 2 == 1 ? 11 : 8; i >= 3; i -= 2) {                 char[] aux = new char[i];                 Arrays.fill(aux, (char) (i + '0'));                 if (fitH(new String(aux), N / 2 - i / 2, N / 2 - i / 2)) {                     int[] f = getGroup(i, i, 0, 0, groupSize, 0);                     if (f != null) {                         placeGroup(f, N / 2 - i / 2, N / 2 - i / 2, 0, 0, 0);                     }                 }             }         }     }      private double improve() {         double ret = eval();         int[][][] bad = new int[16][N][N];         for (int i = 3; i <= 15; i++) {             int[][] bi = bad[i];             for (int y = 0; y < N; y++) {                 int[] biy = bi[y];                 for (int x = 0; x < N; x++) {                     if (!fitAnyH(i, x, y)) biy[x] |= 1;                     if (!fitAnyV(i, x, y)) biy[x] |= 2;                 }             }         }         NEXT: for (int i = 0; i < words.length; i++) {             if (used[i]) continue;             if ((i & 63) == 63 && System.currentTimeMillis() > timeout) return ret;             String wi = words[i];             char c = wi.charAt(0);             int[][] bi = bad[wi.length()];             for (int y = 0; y < N; y++) {                 char[] sy = solution[y];                 int[] biy = bi[y];                 for (int x = 0; x < N; x++) {                     char syx = sy[x];                     if (syx != 0 && c != syx) continue;                     int biyx = biy[x];                     if ((biyx & 1) == 0 && fitH(wi, x, y)) {                         for (int j = 3; j <= 15; j++) {                             bad[j][y][x] |= 1;                         }                         placeH(i, x, y);                         ret = Math.max(eval(), ret);                         continue NEXT;                     }                     if ((biyx & 2) == 0 && fitV(wi, x, y)) {                         for (int j = 3; j <= 15; j++) {                             bad[j][y][x] |= 2;                         }                         placeV(i, x, y);                         ret = Math.max(eval(), ret);                         continue NEXT;                     }                 }             }         }         return ret;     }      private int[] getPair(int len, int maxLen, boolean a, boolean b, boolean c) {         for (int j = 0; j < words.length; j++) {             String sj = words[j];             if (sj.length() >= maxLen || (len != -1 && sj.length() != len)) continue;             if (used[j]) continue;             for (int k = 0; k < words.length; k++) {                 String sk = words[k];                 if (sk.length() != sj.length()) continue;                 if (c && sj.charAt(a ? 0 : sj.length() - 1) != sk.charAt(b ? 0 : sj.length() - 1)) continue;                 if (j == k || used[k]) continue;                 return new int[] {j,k};             }         }         return null;     }      private int[] getGroup(int w, int h) {         return getGroup(w, h, 0);     }      private int[] getGroup(int w, int h, int mode) {         return getGroup(w, h, mode, mode, 4, 0);     }      private int[] getGroup(int w, int h, int modew, int modeh, int size, int dir) {         if (size == 6 && dir == 0 && (w % 2 != 1 || h % 2 != 1)) return null;         if ((size == 5 || size == 7) && dir == 0 && h % 2 != 1) return null;         if ((size == 5 || size == 7) && dir == 1 && w % 2 != 1) return null;         int[] wordsW = wordsBySize[w];         int[][] whm = wordsBySizePosChar[h][modeh];         int[][] wwm = wordsBySizePosChar[w][modew];         for (int j : wordsW) {             if (used[j]) continue;             String sj = words[j];             int sjm = sj.charAt(w >> 1) - 'A';             int sj0 = sj.charAt(modew) - 'A';             int sjw = sj.charAt(w - 1 - modew) - 'A';             for (int k : whm[sj0]) {                 if (w == h && k <= j) continue;                 if (j == k || used[k]) continue;                 String sk = words[k];                 int skm = sk.charAt(h >> 1) - 'A';                 int skh = sk.charAt(h - 1 - modeh) - 'A';                 for (int l : whm[sjw]) {                     if (j == l || k == l || used[l]) continue;                     String sl = words[l];                     char slh = sl.charAt(h - 1 - modeh);                     char slm = sl.charAt(h >> 1);                     for (int m : wwm[skh]) {                         if (j == m || k == m || l == m || used[m]) continue;                         String sm = words[m];                         if (slh != sm.charAt(w - 1 - modew)) continue;                         if (size == 4) return new int[] {j,k,l,m};                          if (size == 5) {                             if (dir == 0) {                                 for (int p : wwm[skm]) {                                     if (j == p || k == p || l == p || m == p || used[p]) continue;                                     String sp = words[p];                                     if (sp.charAt(w - 1 - modew) != slm) continue;                                     return new int[] {j,k,l,m,p};                                 }                             } else if (dir == 1) {                                 char smm = sm.charAt(w >> 1);                                 for (int p : whm[sjm]) {                                     if (j == p || k == p || l == p || m == p || used[p]) continue;                                     String sp = words[p];                                     if (sp.charAt(h - 1 - modeh) != smm) continue;                                     return new int[] {j,k,l,m,p};                                 }                             }                         }                          if (size == 7) {                             if (dir == 0) {                                 for (int p : wwm[skm]) {                                     if (j == p || k == p || l == p || m == p || used[p]) continue;                                     String sp = words[p];                                     if (sp.charAt(w - 1 - modew) != slm) continue;                                      int sk1 = sk.charAt(modeh + 2) - 'A';                                     int sk2 = sk.charAt(h - 1 - modeh - 2) - 'A';                                     char sl1 = sl.charAt(modeh + 2);                                     char sl2 = sl.charAt(h - 1 - modeh - 2);                                     for (int r : wwm[sk1]) {                                         if (j == r || k == r || l == r || m == r || p == r || used[r]) continue;                                         String sr = words[r];                                         if (sr.charAt(w - 1 - modew) != sl1) continue;                                         for (int q : wwm[sk2]) {                                             if (j == q || k == q || l == q || m == q || p == q || r == q || used[q]) continue;                                             String sq = words[q];                                             if (sq.charAt(w - 1 - modew) != sl2) continue;                                             return new int[] {j,k,l,m,r,p,q};                                         }                                     }                                 }                             } else if (dir == 1) {                                 char smm = sm.charAt(w >> 1);                                 for (int p : whm[sjm]) {                                     if (j == p || k == p || l == p || m == p || used[p]) continue;                                     String sp = words[p];                                     if (sp.charAt(h - 1 - modeh) != smm) continue;                                      int sj1 = sj.charAt(modew + 2) - 'A';                                     int sj2 = sj.charAt(w - 1 - modew - 2) - 'A';                                     char sm1 = sm.charAt(modew + 2);                                     char sm2 = sm.charAt(w - 1 - modew - 2);                                     for (int r : whm[sj1]) {                                         if (j == r || k == r || l == r || m == r || p == r || used[r]) continue;                                         String sr = words[r];                                         if (sr.charAt(h - 1 - modeh) != sm1) continue;                                         for (int q : whm[sj2]) {                                             if (j == q || k == q || l == q || m == q || p == q || r == q || used[q]) continue;                                             String sq = words[q];                                             if (sq.charAt(h - 1 - modeh) != sm2) continue;                                             return new int[] {j,k,l,m,r,p,q};                                         }                                     }                                 }                             }                         }                          if (size == 6) {                             if (dir == 0) {                                 char smm = sm.charAt(w >> 1);                                 for (int p : whm[sjm]) {                                     if (j == p || k == p || l == p || m == p || used[p]) continue;                                     String sp = words[p];                                     if (sp.charAt(h - 1 - modeh) != smm) continue;                                     for (int q : wwm[skm]) {                                         if (j == q || k == q || l == q || m == q || p == q || used[q]) continue;                                         String sq = words[q];                                         if (sq.charAt(w - 1 - modew) != slm) continue;                                         if (sq.charAt(w >> 1) != sp.charAt(h >> 1)) continue;                                         return new int[] {j,k,l,m,p,q};                                     }                                 }                             } else if (dir == 1) {                                 int sj1 = sj.charAt(modew + 2) - 'A';                                 int sj2 = sj.charAt(w - 1 - modew - 2) - 'A';                                 char sm1 = sm.charAt(modew + 2);                                 char sm2 = sm.charAt(w - 1 - modew - 2);                                 for (int p : whm[sj1]) {                                     if (j == p || k == p || l == p || m == p || used[p]) continue;                                     String sp = words[p];                                     if (sp.charAt(h - 1 - modeh) != sm1) continue;                                     for (int q : whm[sj2]) {                                         if (j == q || k == q || l == q || m == q || p == q || used[q]) continue;                                         String sq = words[q];                                         if (sq.charAt(h - 1 - modeh) != sm2) continue;                                         return new int[] {j,k,l,m,p,q};                                     }                                 }                             } else if (dir == 2) {                                 int sk1 = sk.charAt(modeh + 2) - 'A';                                 int sk2 = sk.charAt(h - 1 - modeh - 2) - 'A';                                 char sl1 = sl.charAt(modeh + 2);                                 char sl2 = sl.charAt(h - 1 - modeh - 2);                                 for (int p : wwm[sk1]) {                                     if (j == p || k == p || l == p || m == p || used[p]) continue;                                     String sp = words[p];                                     if (sp.charAt(w - 1 - modew) != sl1) continue;                                     for (int q : wwm[sk2]) {                                         if (j == q || k == q || l == q || m == q || p == q || used[q]) continue;                                         String sq = words[q];                                         if (sq.charAt(w - 1 - modew) != sl2) continue;                                         return new int[] {j,k,l,m,p,q};                                     }                                 }                             }                         }                     }                 }             }         }         return null;     }      private int[] getCross(int len) {         int[] wlen = wordsBySize[len];         for (int j : wlen) {             if (used[j]) continue;             String sj = words[j];             for (int k : wlen) {                 if (j == k || used[k]) continue;                 String sk = words[k];                 if (sj.charAt(len >> 1) != sk.charAt(len >> 1)) continue;                 return new int[] {j,k};             }         }         return null;     }      void show() {         for (int i = 0; i < N; i++) {             for (int j = 0; j < N; j++) {                 char c = solution[i][j];                 System.err.print(c == 0 ? '.' : c);             }             System.err.println();         }         System.err.println();     }      void showBest() {         for (int i = 0; i < N; i++) {             for (int j = 0; j < N; j++) {                 char c = bestSolution[i][j];                 System.err.print(c == 0 ? '.' : c);             }             System.err.println();         }         System.err.println();     }      private void sortWords() {         final Map<String, Double> map = new HashMap<String, Double>();         int[] cnt = new int[128];         for (int i = 0; i < words.length; i++) {             String s = words[i];             for (int j = 0; j < s.length(); j++) {                 cnt[s.charAt(j)]++;             }         }         for (int i = 0; i < words.length; i++) {             String s = words[i];             double val = s.length() * 1000;             if (s.length() > N) val = -1e100;             for (int j = 0; j < s.length(); j++) {                 int cc = cnt[s.charAt(j)];                 val += cc * ((j == 0 || j == s.length() - 1) ? -1 : 1);             }             map.put(s, val);         }         Arrays.sort(words, new Comparator<String>() {             public int compare(String a, String b) {                 return (int) Math.signum(map.get(b) - map.get(a));             }         });         prepareWords();     }      private boolean fitH(String s, int x, int y) {         if (s.length() + x > N) return false;         char[] sy = solution[y];         if (x > 0 && sy[x - 1] != 0) return false;         if (x + s.length() < N && sy[x + s.length()] != 0) return false;         for (int i = 0; i < s.length(); i++) {             char c = sy[x + i];             if (c != 0 && c != s.charAt(i)) return false;             if (c == 0 && ((y > 0 && solution[y - 1][x + i] != 0) || (y < N - 1 && solution[y + 1][x + i] != 0))) return false;         }         return true;     }      private boolean fitAnyH(int len, int x, int y) {         if (len + x > N) return false;         char[] sy = solution[y];         if (x > 0 && sy[x - 1] != 0) return false;         if (x + len < N && sy[x + len] != 0) return false;         for (int i = 0; i < len; i++) {             char c = sy[x + i];             if (c == 0 && ((y > 0 && solution[y - 1][x + i] != 0) || (y < N - 1 && solution[y + 1][x + i] != 0))) return false;             if (c != 0 && i > 0 && sy[x + i - 1] != 0) return false;         }         return true;     }      private void placeH(int idx, int x, int y) {         String s = words[idx];         used[idx] = true;         char[] sy = solution[y];         for (int i = 0; i < s.length(); i++) {             sy[x + i] = s.charAt(i);         }     }      private boolean fitV(String s, int x, int y) {         if (s.length() + y > N) return false;         if (y > 0 && solution[y - 1][x] != 0) return false;         if (y + s.length() < N && solution[y + s.length()][x] != 0) return false;         for (int i = 0; i < s.length(); i++) {             char[] sy = solution[y + i];             if (sy[x] != 0 && sy[x] != s.charAt(i)) return false;             if (sy[x] == 0 && ((x > 0 && sy[x - 1] != 0) || (x < N - 1 && sy[x + 1] != 0))) return false;         }         return true;     }      private boolean fitAnyV(int len, int x, int y) {         if (len + y > N) return false;         if (y > 0 && solution[y - 1][x] != 0) return false;         if (y + len < N && solution[y + len][x] != 0) return false;         for (int i = 0; i < len; i++) {             char[] sy = solution[y + i];             char c = sy[x];             if (c == 0 && ((x > 0 && sy[x - 1] != 0) || (x < N - 1 && sy[x + 1] != 0))) return false;             if (c != 0 && i > 0 && solution[y + i - 1][x] != 0) return false;         }         return true;     }      private void placeV(int idx, int x, int y) {         String s = words[idx];         used[idx] = true;         for (int i = 0; i < s.length(); i++) {             solution[y + i][x] = s.charAt(i);         }     }      private void initSolution() {         Arrays.fill(used, false);         for (int i = 0; i < N; i++) {             Arrays.fill(solution[i], (char) 0);         }     }      private double eval() {         int n = 0;         int nr = 0;         int nc = 0;         int cr = 0;         for (int i = 0; i < N; i++) {             char[] si = solution[i];             boolean rf = false;             for (int j = 0; j < N; j++) {                 if (si[j] != 0) {                     n++;                     if (((j > 0 && si[j - 1] != 0) || (j < N - 1 && si[j + 1] != 0)) && ((i > 0 && solution[i - 1][j] != 0) || (i < N - 1 && solution[i + 1][j] != 0))) {                         cr++;                     }                     if (!rf) rf = true;                 }             }             boolean cf = false;             for (int j = 0; j < N; j++) {                 if (solution[j][i] != 0) {                     cf = true;                     break;                 }             }             if (cf) nc++;             if (rf) nr++;         }         double sym = 0;         int tot = 0;         for (int i = 0; i <= N - i - 1; i++) {             for (int j = 0; j <= i; j++) {                 int c = 0;                 if (solution[i][j] == 0) c++;                 if (solution[j][i] == 0) c++;                 if (solution[N - i - 1][j] == 0) c++;                 if (solution[j][N - i - 1] == 0) c++;                 if (solution[i][N - j - 1] == 0) c++;                 if (solution[N - j - 1][i] == 0) c++;                 if (solution[N - i - 1][N - j - 1] == 0) c++;                 if (solution[N - j - 1][N - i - 1] == 0) c++;                 if (c == 0 || c == 8) sym += 1.0;                 if (c == 1 || c == 7) sym += 0.5;                 if (c == 2 || c == 6) sym += 0.1;                 tot++;             }         }         double score = (n / NN * w1 + nc * nr / NN * w2 + sym / tot * w3 + (n == 0 ? 0 : cr / (double) n) * w4) / (w1 + w2 + w3 + w4);         if (score > best) {             best = score;             for (int i = 0; i < N; i++) {                 System.arraycopy(solution[i], 0, bestSolution[i], 0, N);             }         }         return score;     }      private String[] mountRet() {         String[] ret = new String[N];         for (int i = 0; i < N; i++) {             char[] si = bestSolution[i];             for (int j = 0; j < N; j++) {                 if (si[j] == 0) si[j] = '.';             }             ret[i] = new String(si);         }         return ret;     } } 
